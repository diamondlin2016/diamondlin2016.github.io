<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>设计模式前传－－面向对象六大原则 | Diamond_lin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##面向对象1、什么叫面向对象        这个对象不是java中的实例，java语法中，我们把一个类的实例也叫做对象。这种对象严格的说应该是面向对象编程实现（OOP）中的对象，面向对象编程，也不是面向类的实例编程。对象的定义是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体事务，还能表示抽象的规则、计划或事件。也有的定义为“万物皆对象”。
2、为什么要面向对">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式前传－－面向对象六大原则">
<meta property="og:url" content="http://yoursite.com/2016/08/20/Six-principles-of-design-patterns/index.html">
<meta property="og:site_name" content="Diamond_lin">
<meta property="og:description" content="##面向对象1、什么叫面向对象        这个对象不是java中的实例，java语法中，我们把一个类的实例也叫做对象。这种对象严格的说应该是面向对象编程实现（OOP）中的对象，面向对象编程，也不是面向类的实例编程。对象的定义是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体事务，还能表示抽象的规则、计划或事件。也有的定义为“万物皆对象”。
2、为什么要面向对">
<meta property="og:image" content="http://att.bbs.duowan.com/forum/201411/07/051445bgo4oyd4wvcb43xy.jpg">
<meta property="og:image" content="http://www.uml.org.cn/sjms/images/2012110231.jpg">
<meta property="og:image" content="http://www.uml.org.cn/sjms/images/2012110232.jpg">
<meta property="og:image" content="http://www.uml.org.cn/sjms/images/2012110233.jpg">
<meta property="og:image" content="http://www.uml.org.cn/sjms/images/2012110234.jpg">
<meta property="og:updated_time" content="2016-08-20T06:19:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式前传－－面向对象六大原则">
<meta name="twitter:description" content="##面向对象1、什么叫面向对象        这个对象不是java中的实例，java语法中，我们把一个类的实例也叫做对象。这种对象严格的说应该是面向对象编程实现（OOP）中的对象，面向对象编程，也不是面向类的实例编程。对象的定义是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体事务，还能表示抽象的规则、计划或事件。也有的定义为“万物皆对象”。
2、为什么要面向对">
<meta name="twitter:image" content="http://att.bbs.duowan.com/forum/201411/07/051445bgo4oyd4wvcb43xy.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Diamond_lin" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="0" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Diamond_lin</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Diamond_lin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="0" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Diamond_lin</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Six-principles-of-design-patterns" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/20/Six-principles-of-design-patterns/" class="article-date">
  	<time datetime="2016-08-20T05:54:47.000Z" itemprop="datePublished">2016-08-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式前传－－面向对象六大原则
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="##面向对象"></a>##面向对象</h1><p><strong>1、什么叫面向对象</strong><br>        这个对象不是java中的实例，java语法中，我们把一个类的实例也叫做对象。这种对象严格的说应该是面向对象编程实现（OOP）中的对象，面向对象编程，也不是面向类的实例编程。对象的定义是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体事务，还能表示抽象的规则、计划或事件。也有的定义为“万物皆对象”。</p>
<p><strong>2、为什么要面向对象</strong></p>
<pre><code>面向对象是为了解决系统的可维护性，可扩展性，可重用性，我们再进一步思考，面向对象为什么能解决系统的可维护性，可扩展性，可重用性？
</code></pre><p>（面向对象的理解不够深刻，待扩展）</p>
<h1 id="设计模式前传——面向对象六大基本原则"><a href="#设计模式前传——面向对象六大基本原则" class="headerlink" title="##设计模式前传——面向对象六大基本原则"></a>##设计模式前传——面向对象六大基本原则</h1><p><strong>＊单一职能原则</strong></p>
<p><strong>＊里氏替换原则</strong></p>
<p><strong>＊依赖倒置原则</strong></p>
<p><strong>＊接口隔离原则</strong></p>
<p><strong>＊迪米特原则</strong></p>
<p><strong>＊开闭原则</strong></p>
<h2 id="单一职能原则"><a href="#单一职能原则" class="headerlink" title="####单一职能原则"></a>####单一职能原则</h2><p><strong>＊定义</strong>：不要存在多于一个导致类变更的原因，即一个类只负责一项职责。</p>
<p><strong>＊难点</strong>：职责的划分</p>
<p><strong>＊划分</strong>：在不同的情景和生产环境下，我们对职责的细化不同的（职责单一的相对性）单一职责原则提出的是一个评价接口是否优良的标准，但是职责和变化的原因是不可度量的，因项目而异，因环境而异（不可度量性）</p>
<p><strong>＊优势</strong>：</p>
<ul>
<li>类的复杂性降低：每个类或接口都只实现单一的职责，定义明确清晰</li>
<li>可读性提高:定义明确清晰，自然带来较高的代码可读性</li>
<li>可维护性提高:代码可读性强，更容易理解，自然方便维护，而且职责单一所以类之间耦合度较低，所以更容易修改。</li>
<li>拓展性更好:有新的职责需要拓展，只需要继承对应的接口实现新的实现即可。</li>
</ul>
<p><strong>＊解决方案</strong>：遵循单一指责原则，分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p><strong>＊举例</strong>:引用网上一个经典的案例，动物呼吸～</p>
<pre><code>class Animal{
    public void breathe(String animal){
        System.out.println(animal+&quot;呼吸空气&quot;);
    }
}
public class Client{
    public static void main(String[] args){
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
    }
} 
</code></pre><p>运行结果：</p>
<pre><code>牛呼吸空气

羊呼吸空气

猪呼吸空气
</code></pre><p><em>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下</em>：</p>
<pre><code>class Terrestrial{
    public void breathe(String animal){
        System.out.println(animal+&quot;呼吸空气&quot;);
    }
}
class Aquatic{
    public void breathe(String animal){
        System.out.println(animal+&quot;呼吸水&quot;);
    }
}

public class Client{
    public static void main(String[] args){
        Terrestrial terrestrial = new Terrestrial();
        terrestrial.breathe(&quot;牛&quot;);
        terrestrial.breathe(&quot;羊&quot;);
        terrestrial.breathe(&quot;猪&quot;);

        Aquatic aquatic = new Aquatic();
        aquatic.breathe(&quot;鱼&quot;);
    }
}
</code></pre><p>运行结果：</p>
<pre><code>牛呼吸空气

羊呼吸空气

猪呼吸空气

鱼呼吸水
</code></pre><p><em>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</em></p>
<pre><code>class Animal{
    public void breathe(String animal){
        if(&quot;鱼&quot;.equals(animal)){
            System.out.println(animal+&quot;呼吸水&quot;);
        }else{
            System.out.println(animal+&quot;呼吸空气&quot;);
        }
    }
}

public class Client{
    public static void main(String[] args){
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe(&quot;鱼&quot;);
    }
} 
</code></pre><p><em>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</em></p>
<pre><code>class Animal{
    public void breathe(String animal){
        System.out.println(animal+&quot;呼吸空气&quot;);
    }

    public void breathe2(String animal){
        System.out.println(animal+&quot;呼吸水&quot;);
    }
}

public class Client{
    public static void main(String[] args){
        Animal animal = new Animal();
        animal.breathe(&quot;牛&quot;);
        animal.breathe(&quot;羊&quot;);
        animal.breathe(&quot;猪&quot;);
        animal.breathe2(&quot;鱼&quot;);
    }
} 
</code></pre><p><em>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则。</em></p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="####里氏替换原则"></a>####里氏替换原则</h2><p><strong>＊定义1</strong>：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，程序 P 中所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>
<p><strong>＊定义2</strong>：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p><strong>＊问题由来</strong>：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p><strong>＊解决方案</strong>：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p><strong>＊继承包含这样一层含义</strong>：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<ul>
<li>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</li>
</ul>
<p><img src="http://att.bbs.duowan.com/forum/201411/07/051445bgo4oyd4wvcb43xy.jpg" alt="image"></p>
<p><em>我们需要完成一个两数相减的功能，由类A来负责。</em></p>
<pre><code>class A{
    public int func1(int a, int b){
        return a-b;
    }
}

public class Client{
    public static void main(String[] args){
        A a = new A();
        System.out.println(&quot;100-50=&quot;+a.func1(100, 50));
        System.out.println(&quot;100-80=&quot;+a.func1(100, 80));
    }
} 
</code></pre><p>运行结果：</p>
<pre><code>100-50=50

100-80=20
</code></pre><p><em>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</em></p>
<p>＊两数相减。</p>
<p>＊两数相加，然后再加100。</p>
<p><em>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</em></p>
<pre><code>class B extends A{
    public int func1(int a, int b){
        return a+b;
    }

    public int func2(int a, int b){
        return func1(a,b)+100;
    }
}

public class Client{
    public static void main(String[] args){
        B b = new B();
        System.out.println(&quot;100-50=&quot;+b.func1(100, 50));
        System.out.println(&quot;100-80=&quot;+b.func1(100, 80));
        System.out.println(&quot;100+20+100=&quot;+b.func2(100, 20));
    }
} 
</code></pre><p>类B完成后，运行结果：</p>
<pre><code>100-50=150

100-80=180

100+20+100=220
</code></pre><p><em>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</em></p>
<ul>
<li><p>子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
</ul>
</li>
</ul>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p>
<p><strong>后果就是</strong>：你写的代码出问题的几率将会大大增加。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="####依赖倒置原则"></a>####依赖倒置原则</h2><p><strong>原始定义</strong>：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</p>
<p><strong>翻译过来就三层定义</strong>：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</p>
<ul>
<li><p>抽象：即抽象类或接口，两者是不能够实例化的。</p>
</li>
<li><p>细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。</p>
</li>
</ul>
<p><em>现在我们来通过实例还原开篇问题的场景，以便更好的来理解。下面代码描述了一个简单的场景，Jim作为人有吃的方法，苹果有取得自己名字的方法，然后实现Jim去吃苹果。</em></p>
<pre><code>//具体Jim人类
public class Jim {
    public void eat(Apple apple){
        System.out.println(&quot;Jim eat &quot; + apple.getName());
    }
}
//具体苹果类
public class Apple {
    public String getName(){
    return &quot;apple&quot;;
    }
}
public class Client {
    public static void main(String[] args) {
        Jim jim = new Jim();
        Apple apple = new Apple();
        jim.eat(apple);
    }
}
</code></pre><p>运行结果：</p>
<pre><code>Jim eat apple
</code></pre><p>　　<em>上面代码看起来比较简单，但其实是一个非常脆弱的设计。现在Jim可以吃苹果了，但是不能只吃苹果而不吃别的水果啊，这样下去肯定会造成营养失衡。现在想让Jim吃香蕉了（好像香蕉里含钾元素比较多，吃点比较有益），突然发现Jim是吃不了香蕉的，那怎么办呢？看来只有修改代码了啊，由于上面代码中Jim类依赖于Apple类，所以导致不得不去改动Jim类里面的代码。那如果下次Jim又要吃别的水果了呢？继续修改代码？这种处理方式显然是不可取的，频繁修改会带来很大的系统风险，改着改着可能就发现Jim不会吃水果了。</em></p>
<p>　　<em>上面的代码之所以会出现上述难堪的问题，就是因为Jim类依赖于Apple类，两者是紧耦合的关系，其导致的结果就是系统的可维护性大大降低。要增加香蕉类却要去修改Jim类代码，这是不可忍受的，你改你的代码为什么要动我的啊，显然Jim不乐意了。我们常说要设计一个健壮稳定的系统，而这里只是增加了一个香蕉类，就要去修改Jim类，健壮和稳定还从何谈起。</em></p>
<p>　　<em>而根据依赖倒置原则，我们可以对上述代码做些修改，提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。</em></p>
<pre><code>//人接口
public interface People {
    public void eat(Fruit fruit);//人都有吃的方法，不然都饿死了
}
//水果接口
public interface Fruit {
    public String getName();//水果都是有名字的
}
//具体Jim人类
public class Jim implements People{
    public void eat(Fruit fruit){
        System.out.println(&quot;Jim eat &quot; + fruit.getName());
    }
}
//具体苹果类
public class Apple implements Fruit{
    public String getName(){
        return &quot;apple&quot;;
    }
}
//具体香蕉类
public class Banana implements Fruit{
    public String getName(){
        return &quot;banana&quot;;
    }
}
public class Client {
    public static void main(String[] args) {
        People jim = new Jim();
        Fruit apple = new Apple();
        Fruit Banana = new Banana();//这里符合了里氏替换原则
        jim.eat(apple);
        jim.eat(Banana);
    }
}
</code></pre><p>运行结果：</p>
<pre><code>Jim eat apple

Jim eat banana
</code></pre><ul>
<li>People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，这就做到了：高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。</li>
<li>People和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节（具体实现类）。</li>
<li>Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。</li>
</ul>
<p><strong>什么是倒置</strong></p>
<p>　　到了这里，我们对依赖倒置原则的“依赖”就很好理解了，但是什么是“倒置”呢。是这样子的，刚开始按照正常人的一般思维方式，我想吃香蕉就是吃香蕉，想吃苹果就吃苹果，编程也是这样，都是按照面向实现的思维方式来设计。而现在要倒置思维，提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。</p>
<p><strong>依赖的三种实现方式</strong></p>
<ul>
<li>接口方法中声明依赖对象。就是我们上面代码所展示的那样。</li>
<li>构造方法传递依赖对象。在构造函数中的需要传递的参数是抽象类或接口的方式实现。代码如下:</li>
</ul>
<pre><code>//具体Jim人类
public class Jim implements People{
    private Fruit fruit;
    public Jim(Fruit fruit){//构造方法传递依赖对象
        this.fruit = fruit;
    }
    public void eat(){
        System.out.println(&quot;Jim eat&quot;+fruit.getName());
    }
}
</code></pre><ul>
<li>Setter方法传递依赖对象。在我们设置的setXXX方法中的参数为抽象类或接口，来实现传递依赖对象。代码如下：</li>
</ul>
<pre><code>//具体Jim人类
public class Jim implements People{
    private Fruit fruit;
    public void setFruit(Fruit fruit){//seetter方式传递依赖
        this.fruit = fruit;
    }
    public void eat(){
        System.out.println(&quot;Jim eat&quot;+fruit.getName());
    }
}
</code></pre><p><strong>优点</strong>:</p>
<ul>
<li>从上面的代码修改过程中，我们可以看到由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖细节，所以在修改某个类的代码时，不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。</li>
<li>还有一个优点是，在我们实际项目开发中，都是多人团队协作，每人负责某一模块。比如一个人负责开发People模块，一人负责开发Fruit模块，如果未采用依赖倒置原则，没有提取抽象，那么开发People模块的人必须等Fruit模块开发完成后自己才能开发，否则编译都无法通过，这就是单线程的开发。为了能够两人并行开发，设计时遵循依赖倒置原则，提取抽象，就可以大大提高开发进度。</li>
</ul>
<p><em>说到底，依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不要依赖于具体实现。依赖倒置原则的本质其实就是通过抽象（抽象类或接口）使各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。但是这个原则也是6个设计原则中最难以实现的了，如果没有实现这个原则，那么也就意味着开闭原则（对扩展开放，对修改关闭）也无法实现。</em></p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="####接口隔离原则"></a>####接口隔离原则</h2><p><strong>定义</strong>：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p><strong>问题由来</strong>：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p>
<p><strong>解决方案</strong>：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p><img src="http://www.uml.org.cn/sjms/images/2012110231.jpg" alt="image"></p>
<p>如图：</p>
<pre><code>*类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。*
</code></pre><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如下图所示：</p>
<p><img src="http://www.uml.org.cn/sjms/images/2012110232.jpg" alt="image"></p>
<p><strong>接口隔离原则的含义是：</strong>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p><strong>接口隔离原则跟之前的单一职责原则</strong></p>
<ul>
<li>单一职责原则原注重的是职责；接口隔离原则注重对接口依赖的隔离。</li>
<li>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li>
</ul>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<p><strong>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</strong></p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="####迪米特法则"></a>####迪米特法则</h2><p><strong>定义</strong>：一个对象应该对其他对象保持最少的了解。</p>
<p><strong>问题由来</strong>：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p><strong>解决方案</strong>：尽量降低类与类之间的耦合。</p>
<p><em>自从我们接触编程开始，就知道了软件编程的总的原则：<strong>低耦合，高内聚</strong>。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</em></p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p>
<pre><code>//总公司员工
class Employee{
    private String id;
    public void setId(String id){
        this.id = id;
    }
    public String getId(){
        return id;
    }
}

//分公司员工
class SubEmployee{
    private String id;
    public void setId(String id){
        this.id = id;
    }
    public String getId(){
        return id;
    }
}

class SubCompanyManager{
    public List&lt;SubEmployee&gt; getAllEmployee(){
        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();
        for(int i=0; i&lt;100; i++){
            SubEmployee emp = new SubEmployee();
            //为分公司人员按顺序分配一个ID
            emp.setId(&quot;分公司&quot;+i);
            list.add(emp);
        }
        return list;
    }
}

class CompanyManager{
    public List&lt;Employee&gt; getAllEmployee(){
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        for(int i=0; i&lt;30; i++){
            Employee emp = new Employee();
            //为总公司人员按顺序分配一个ID
            emp.setId(&quot;总公司&quot;+i);
            list.add(emp);
        }
        return list;
    }    
    public void printAllEmployee(SubCompanyManager sub){
        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();
        for(SubEmployee e:list1){
            System.out.println(e.getId());
        }
        //以上打印分公司员工的代码应该由SubCompanyManager来提供打印方法。
        List&lt;Employee&gt; list2 = this.getAllEmployee();
        for(Employee e:list2){
            System.out.println(e.getId());
        }
    }
}
public class Client{
    public static void main(String[] args){
        CompanyManager e = new CompanyManager();
        e.printAllEmployee(new SubCompanyManager());
    }
} 
</code></pre><p><strong>分析</strong>：现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。</p>
<p><strong>修改方案</strong>：CompanyManager提供打印方法，在CompanyManager的printAllEmployee调用SubCompanyManager.printEmployee()即可。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="####开闭原则"></a>####开闭原则</h2><p><strong>定义</strong>：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p><strong>问题由来</strong>：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p><strong>解决方案</strong>：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<blockquote>
<pre><code>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。
</code></pre><p>   在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p>
</blockquote>
<hr>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</p>
<p><img src="http://www.uml.org.cn/sjms/images/2012110233.jpg" alt="image"></p>
<p>＊＊＊图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</p>
<p><img src="http://www.uml.org.cn/sjms/images/2012110234.jpg" alt="image"><br>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/08/18/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hello World</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Six-principles-of-design-patterns" data-title="设计模式前传－－面向对象六大原则" data-url="http://yoursite.com/2016/08/20/Six-principles-of-design-patterns/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Diamond_lin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>